# THINKFAST 로깅 시스템 개발 및 기능 정의서

**작성일**: 2025-01-15  
**버전**: 1.0

---

## 목차

1. [시스템 개요](#1-시스템-개요)
2. [아키텍처 및 구성 요소](#2-아키텍처-및-구성-요소)
3. [기능별 상세 정의](#3-기능별-상세-정의)
4. [설정 및 구성](#4-설정-및-구성)
5. [사용 방법](#5-사용-방법)
6. [로그 스키마](#6-로그-스키마)

---

## 1. 시스템 개요

### 1.1 목적

THINKFAST WAS의 모든 로그를 구조화된 JSON 형식으로 출력하여 ELK 스택(Elasticsearch, Logstash, Kibana)과 연동하여 운영 장애 분석, 예외 추적, 성능 모니터링을 수행합니다.

### 1.2 주요 특징

- **구조화된 JSON 로깅**: ELK 스택과 호환되는 JSON 포맷
- **MDC 기반 추적**: Request ID, Trace ID를 통한 요청 추적
- **예외 처리**: 모든 레벨(Filter, Interceptor, Handler)에서 예외 로깅
- **성능 측정**: HTTP 요청, 외부 API 호출, 메서드 실행 시간 측정
- **로깅 샘플링**: 성능 최적화를 위한 로그 샘플링 (성공 요청 10%)
- **민감 정보 보호**: 자동 마스킹을 통한 민감 정보 보호

---

## 2. 아키텍처 및 구성 요소

### 2.1 전체 구조

```
HTTP Request
    ↓
[RequestIdFilter] - Request ID/Trace ID 생성
    ↓
[ExceptionLoggingFilter] - 필터 레벨 예외 감지
    ↓
[LoggingInterceptor] - HTTP 요청/응답 로깅
    ↓
[Controller]
    ↓
[Service] - @PerformanceLog 어노테이션으로 성능 측정
    ↓
[External APIs] - Gemini, Redis 등 외부 시스템 로깅
    ↓
[GlobalExceptionHandler] - 컨트롤러 예외 처리 및 로깅
    ↓
[Logback] - JSON Encoder로 구조화된 로그 출력
    ↓
[File/Console] - JSON 로그 파일 또는 콘솔 출력
```

### 2.2 핵심 컴포넌트

| 컴포넌트 | 클래스명 | 위치 | 역할 |
|---------|---------|------|------|
| Request ID 필터 | `RequestIdFilter` | `common.logger` | 요청별 고유 ID 생성 |
| 예외 로깅 필터 | `ExceptionLoggingFilter` | `common.logger` | 필터 레벨 예외 감지 |
| HTTP 로깅 인터셉터 | `LoggingInterceptor` | `common.logger` | HTTP 요청/응답 로깅 |
| 전역 예외 핸들러 | `GlobalExceptionHandler` | `common.aop` | 컨트롤러 예외 처리 |
| 성능 로깅 AOP | `PerformanceLoggingAspect` | `common.aop` | 메서드 성능 측정 |
| 전역 예외 핸들러 | `GlobalUncaughtExceptionHandler` | `common.logger` | 스레드 예외 처리 |
| 비동기 예외 핸들러 | `CustomAsyncUncaughtExceptionHandler` | `common.logger` | 비동기 작업 예외 처리 |
| 로그 설정 | `logback-spring.xml` | `resources` | Logback JSON Encoder 설정 |

---

## 3. 기능별 상세 정의

### 3.1 Request ID 추적 시스템

#### 3.1.1 기능 개요

HTTP 요청마다 고유한 Request ID와 Trace ID를 생성하여 모든 로그에 자동으로 포함시켜 요청 추적을 가능하게 합니다.

#### 3.1.2 구현 위치

- **클래스**: `com.example.thinkfast.common.logger.RequestIdFilter`
- **부모 클래스**: `OncePerRequestFilter`
- **어노테이션**: `@Component`, `@Order(1)`

#### 3.1.3 주요 기능

1. **Request ID 생성**
   - HTTP 헤더 `X-Request-ID`가 있으면 사용
   - 없으면 `req-{UUID}` 형식으로 생성 (예: `req-abc123def456...`)

2. **Trace ID 생성**
   - `TraceIdGenerator.generate()`를 사용하여 UUID 기반 Trace ID 생성
   - 분산 시스템 간 추적을 위한 ID

3. **MDC 설정**
   - `request_id`: Request ID를 MDC에 설정
   - `trace_id`: Trace ID를 MDC에 설정

4. **응답 헤더 설정**
   - 응답 헤더에 `X-Request-ID`와 `X-Trace-ID` 추가

5. **MDC 정리**
   - 요청 완료 시 `finally` 블록에서 `MDC.clear()` 호출

#### 3.1.4 코드 구조

```java
@Component
@Order(1)
public class RequestIdFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response,
                                    FilterChain filterChain) {
        try {
            // Request ID 생성 또는 헤더에서 추출
            String requestId = request.getHeader("X-Request-ID");
            if (requestId == null || requestId.isEmpty()) {
                requestId = "req-" + UUID.randomUUID().toString().replace("-", "");
            }
            
            // Trace ID 생성
            String traceId = TraceIdGenerator.generate();
            
            // MDC 설정
            MDC.put("request_id", requestId);
            MDC.put("trace_id", traceId);
            
            // 응답 헤더 설정
            response.setHeader("X-Request-ID", requestId);
            response.setHeader("X-Trace-ID", traceId);
            
            filterChain.doFilter(request, response);
        } finally {
            MDC.clear(); // MDC 정리
        }
    }
}
```

#### 3.1.5 동작 흐름

1. 요청이 들어오면 가장 먼저 실행 (`@Order(1)`)
2. Request ID 생성 또는 헤더에서 추출
3. Trace ID 생성
4. MDC에 설정 (이후 모든 로그에 자동 포함)
5. 응답 헤더에 ID 추가
6. 요청 완료 후 MDC 정리

---

### 3.2 HTTP 요청/응답 로깅

#### 3.2.1 기능 개요

HTTP 요청과 응답에 대한 상세 정보를 구조화된 로그로 기록합니다. 느린 요청 감지, 성능 측정, 로그 샘플링 등을 포함합니다.

#### 3.2.2 구현 위치

- **클래스**: `com.example.thinkfast.common.logger.LoggingInterceptor`
- **인터페이스**: `HandlerInterceptor`
- **어노테이션**: `@Component`

#### 3.2.3 주요 기능

1. **요청 시작 로깅** (`preHandle`)
   - 요청 시작 시간 기록
   - 사용자 ID 추출 및 MDC 설정
   - HTTP 메타데이터 MDC 설정:
     - `log_type`: "http_request"
     - `http.method`: HTTP 메서드 (GET, POST 등)
     - `http.uri`: 요청 URI
     - `http.client_ip`: 클라이언트 IP (프록시 환경 고려)
     - `http.user_agent`: User-Agent 헤더
     - `http.content_type`: Content-Type

2. **응답 완료 로깅** (`afterCompletion`)
   - 응답 시간 측정
   - HTTP 상태 코드, 응답 크기 등 기록
   - 느린 요청 감지 (3초 이상)
   - 로그 샘플링 적용 (성공 요청 10%)

3. **사용자 ID 추출**
   - `SecurityContext`에서 인증된 사용자 정보 추출
   - `user_id`를 MDC에 설정

4. **클라이언트 IP 추출**
   - `X-Forwarded-For` 헤더 우선 확인
   - `X-Real-IP` 헤더 확인
   - 없으면 `request.getRemoteAddr()` 사용

5. **느린 요청 감지**
   - 임계값: 3초 (3000ms)
   - 느린 요청은 100% 로깅 (샘플링 제외)

6. **로그 샘플링**
   - 성공 요청 (상태 코드 < 400): 10%만 로깅
   - 에러/경고 요청: 100% 로깅
   - 느린 요청: 100% 로깅

#### 3.2.4 코드 구조

```java
@Component
public class LoggingInterceptor implements HandlerInterceptor {
    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000; // 3초
    private static final double SUCCESS_REQUEST_SAMPLING_RATE = 0.1; // 10%
    
    @Override
    public boolean preHandle(HttpServletRequest request, ...) {
        long startTime = System.currentTimeMillis();
        request.setAttribute("startTime", startTime);
        
        // 사용자 ID 추출
        String userId = extractUserId();
        if (userId != null) {
            MDC.put("user_id", userId);
        }
        
        // HTTP 메타데이터 MDC 설정
        MDC.put("log_type", "http_request");
        MDC.put("http.method", request.getMethod());
        MDC.put("http.uri", request.getRequestURI());
        MDC.put("http.client_ip", getClientIpAddress(request));
        // ... 기타 필드
        
        log.info("HTTP request received: {} {}", request.getMethod(), request.getRequestURI());
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, ...) {
        Long startTime = (Long) request.getAttribute("startTime");
        if (startTime == null) return;
        
        long duration = System.currentTimeMillis() - startTime;
        
        // HTTP 응답 정보 설정
        MDC.put("http.status", String.valueOf(response.getStatus()));
        MDC.put("http.duration_ms", String.valueOf(duration));
        
        // 느린 요청 감지
        boolean isSlowRequest = duration > SLOW_REQUEST_THRESHOLD_MS;
        if (isSlowRequest) {
            MDC.put("http.slow_request", "true");
            log.warn("Slow request detected: ...");
        }
        
        // 로그 샘플링
        if (response.getStatus() < 400) {
            if (isSlowRequest || random.nextDouble() < SUCCESS_REQUEST_SAMPLING_RATE) {
                log.info("HTTP response: ...");
            }
        } else {
            log.warn("HTTP error response: ...");
        }
        
        // MDC 정리
        // ...
    }
}
```

#### 3.2.5 등록 방법

`WebConfig` 클래스에서 인터셉터로 등록:

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Autowired
    private LoggingInterceptor loggingInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loggingInterceptor);
    }
}
```

#### 3.2.6 로그 출력 예시

**Local 환경 (텍스트 포맷)**:
```
2024-01-15 12:00:00.000 [http-nio-8080-exec-1] INFO  c.e.t.common.logger.LoggingInterceptor - HTTP request received: POST /api/surveys
```

**Production 환경 (JSON 포맷)**:
```json
{
  "@timestamp": "2024-01-15T12:00:00.000Z",
  "level": "INFO",
  "service": "thinkfast",
  "env": "prod",
  "log_type": "http_request",
  "request_id": "req-abc123",
  "trace_id": "trace-xyz789",
  "user_id": "user@example.com",
  "http.method": "POST",
  "http.uri": "/api/surveys",
  "http.status": "200",
  "http.duration_ms": "145",
  "http.client_ip": "192.168.1.100",
  "message": "HTTP response: POST /api/surveys => 200 (145ms)"
}
```

---

### 3.3 예외 로깅 시스템

#### 3.3.1 필터 레벨 예외 로깅

**클래스**: `com.example.thinkfast.common.logger.ExceptionLoggingFilter`

**주요 기능**:
1. `Exception` 및 `Error` 타입 모두 캐치
2. HTTP 상태 코드 기반 에러 감지 (401, 403, 500+)
3. 중복 로깅 방지 (`exceptionLogged` 속성 사용)
4. 구조화된 예외 정보 로깅

**코드 구조**:
```java
@Component
public class ExceptionLoggingFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(...) {
        try {
            filterChain.doFilter(request, response);
        } catch (Exception ex) {
            if (request.getAttribute("exceptionLogged") == null) {
                logStructuredException(request, ex, "exception");
                request.setAttribute("exceptionLogged", true);
            }
            throw ex;
        } catch (Error error) {
            // Error 타입도 캐치 (OutOfMemoryError 등)
            if (request.getAttribute("exceptionLogged") == null) {
                logStructuredException(request, error, "error");
                request.setAttribute("exceptionLogged", true);
            }
            throw error;
        }
        
        // 상태 코드 기반 에러 감지
        int status = response.getStatus();
        if ((status == 401 || status == 403 || status >= 500) 
            && request.getAttribute("exceptionLogged") == null) {
            // 에러 로깅
        }
    }
    
    private void logStructuredException(...) {
        MDC.put("log_type", "exception");
        MDC.put("error.type", throwable.getClass().getName());
        MDC.put("error.message", throwable.getMessage());
        MDC.put("error.severity", determineSeverity(throwable));
        MDC.put("error.stack_trace", getStackTrace(throwable));
        // 원인 예외, 최상위 원인 예외 등
        log.error("Exception occurred: ...", throwable);
    }
}
```

#### 3.3.2 컨트롤러 레벨 예외 로깅

**클래스**: `com.example.thinkfast.common.aop.GlobalExceptionHandler`

**주요 기능**:
1. `@RestControllerAdvice`로 모든 컨트롤러 예외 처리
2. 예외 타입별 구조화된 로깅
3. 비즈니스 예외 vs 시스템 예외 구분
4. 예외 발생 컨텍스트 정보 추가 (요청 파라미터, 사용자 정보 등)

**코드 구조**:
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<BaseResponse> handleUsernameNotFoundException(...) {
        logStructuredException(request, e, "business", false);
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(BaseResponse.fail(ResponseMessage.INVALID_CREDENTIALS));
    }
    
    @ExceptionHandler(AiServiceException.class)
    public ResponseEntity<BaseResponse> handleAiServiceException(...) {
        logStructuredException(request, e, "system", true);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(BaseResponse.fail("AI 서비스 처리 중 오류가 발생했습니다."));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleAllExceptions(...) {
        if (request.getAttribute("exceptionLogged") == null) {
            logStructuredException(request, ex, "system", true);
            request.setAttribute("exceptionLogged", true);
        }
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("서버 내부 오류가 발생했습니다.");
    }
    
    private void logStructuredException(...) {
        MDC.put("log_type", "exception");
        MDC.put("error.type", throwable.getClass().getName());
        MDC.put("error.message", throwable.getMessage());
        MDC.put("error.severity", exceptionCategory.equals("system") ? "error" : "warn");
        MDC.put("error.category", exceptionCategory); // business vs system
        MDC.put("http.method", request.getMethod());
        MDC.put("http.uri", request.getRequestURI());
        
        // 사용자 정보 추가
        String userId = extractUserId();
        if (userId != null) {
            MDC.put("user_id", userId);
        }
        
        // 요청 파라미터 정보 (민감 정보 제외)
        String queryString = request.getQueryString();
        if (queryString != null) {
            MDC.put("http.query_string", maskSensitiveInfo(queryString));
        }
        
        // 스택 트레이스 (시스템 예외만)
        if (includeStackTrace) {
            MDC.put("error.stack_trace", getStackTrace(throwable));
        }
        
        // 원인 예외, 최상위 원인 예외 정보
        // ...
    }
}
```

#### 3.3.3 전역 예외 핸들러

**클래스**: `com.example.thinkfast.common.logger.GlobalUncaughtExceptionHandler`

**주요 기능**:
1. Thread 기본 UncaughtExceptionHandler 설정
2. `Error` 타입 예외 (OutOfMemoryError 등) 구조화된 로깅
3. 스레드 정보 포함

**코드 구조**:
```java
@Component
public class GlobalUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
    @PostConstruct
    public void init() {
        Thread.setDefaultUncaughtExceptionHandler(this);
    }
    
    @Override
    public void uncaughtException(Thread thread, Throwable throwable) {
        logStructuredException(thread, throwable);
    }
    
    private void logStructuredException(Thread thread, Throwable throwable) {
        MDC.put("log_type", "exception");
        MDC.put("error.type", throwable.getClass().getName());
        MDC.put("error.message", throwable.getMessage());
        MDC.put("error.severity", determineSeverity(throwable));
        MDC.put("thread.name", thread.getName());
        MDC.put("thread.id", String.valueOf(thread.getId()));
        MDC.put("thread.state", thread.getState().name());
        MDC.put("error.stack_trace", getStackTrace(throwable));
        // ...
        log.error("Uncaught exception in thread {}: ...", thread.getName(), throwable);
    }
}
```

#### 3.3.4 비동기 작업 예외 로깅

**클래스**: `com.example.thinkfast.common.logger.CustomAsyncUncaughtExceptionHandler`

**주요 기능**:
1. `@Async` 메서드에서 발생한 예외 처리
2. 비동기 작업 예외 구조화된 로깅
3. 작업 ID, 스레드 정보 포함

**코드 구조**:
```java
public class CustomAsyncUncaughtExceptionHandler 
        implements AsyncUncaughtExceptionHandler {
    @Override
    public void handleUncaughtException(Throwable throwable, 
                                        Method method, 
                                        Object... params) {
        MDC.put("log_type", "exception");
        MDC.put("error.type", throwable.getClass().getName());
        MDC.put("error.message", throwable.getMessage());
        MDC.put("error.severity", "error");
        MDC.put("async.method", method.getDeclaringClass().getSimpleName() + "." + method.getName());
        MDC.put("async.thread", Thread.currentThread().getName());
        MDC.put("error.stack_trace", getStackTrace(throwable));
        
        // 파라미터 정보
        if (params != null && params.length > 0) {
            MDC.put("async.parameters", ...);
        }
        
        log.error("Uncaught exception in async method: {} (thread: {})", 
                method.getName(), Thread.currentThread().getName(), throwable);
    }
}
```

**등록 방법** (현재는 미구현, 권장사항):
```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new CustomAsyncUncaughtExceptionHandler();
    }
}
```

---

### 3.4 성능 측정 시스템

#### 3.4.1 기능 개요

AOP를 사용하여 `@PerformanceLog` 어노테이션이 적용된 메서드의 실행 시간을 자동으로 측정하고 로깅합니다.

#### 3.4.2 구현 위치

- **Aspect**: `com.example.thinkfast.common.aop.PerformanceLoggingAspect`
- **어노테이션**: `com.example.thinkfast.common.annotation.PerformanceLog`

#### 3.4.3 PerformanceLog 어노테이션

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PerformanceLog {
    /**
     * 느린 실행으로 간주할 임계값 (밀리초)
     * 기본값: 1000ms (1초)
     */
    long slowThresholdMs() default 1000;
    
    /**
     * 로그 레벨
     * 기본값: INFO
     */
    String level() default "INFO";
}
```

#### 3.4.4 PerformanceLoggingAspect

**주요 기능**:
1. `@PerformanceLog` 어노테이션이 적용된 메서드 자동 감지
2. 메서드 실행 시간 측정
3. 느린 실행 감지 (기본 1초, 어노테이션으로 설정 가능)
4. 파라미터 정보 로깅 (최대 3개, 100자 제한)
5. 예외 발생 시 예외 정보 로깅

**코드 구조**:
```java
@Aspect
@Component
public class PerformanceLoggingAspect {
    @Around("@annotation(com.example.thinkfast.common.annotation.PerformanceLog)")
    public Object logPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        PerformanceLog performanceLog = method.getAnnotation(PerformanceLog.class);
        
        long startTime = System.currentTimeMillis();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        String methodName = method.getName();
        
        Object result = null;
        Throwable exception = null;
        
        try {
            result = joinPoint.proceed();
            return result;
        } catch (Throwable throwable) {
            exception = throwable;
            throw throwable;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            long slowThreshold = performanceLog.slowThresholdMs();
            boolean isSlow = duration > slowThreshold;
            
            // MDC 설정
            MDC.put("log_type", "performance");
            MDC.put("performance.class", className);
            MDC.put("performance.method", methodName);
            MDC.put("performance.duration_ms", String.valueOf(duration));
            MDC.put("performance.slow", String.valueOf(isSlow));
            
            // 파라미터 정보
            Object[] args = joinPoint.getArgs();
            if (args != null && args.length > 0) {
                // 최대 3개, 100자 제한
                MDC.put("performance.parameters", ...);
            }
            
            // 예외 발생 여부
            if (exception != null) {
                MDC.put("performance.exception", exception.getClass().getSimpleName());
                MDC.put("performance.success", "false");
                log.error("Performance: {} executed in {}ms (exception: {})", 
                        fullMethodName, duration, exception.getClass().getSimpleName(), exception);
            } else {
                MDC.put("performance.success", "true");
                if (isSlow) {
                    log.warn("Performance: {} executed in {}ms (slow)", fullMethodName, duration);
                } else {
                    log.info("Performance: {} executed in {}ms", fullMethodName, duration);
                }
            }
            
            // MDC 정리
            // ...
        }
    }
}
```

#### 3.4.5 사용 방법

서비스 메서드에 `@PerformanceLog` 어노테이션 추가:

```java
@Service
public class SurveyService {
    @PerformanceLog(slowThresholdMs = 2000, level = "INFO")
    public Survey getSurvey(Long id) {
        // 메서드 실행 시간이 자동으로 로깅됨
        return surveyRepository.findById(id).orElseThrow();
    }
    
    @PerformanceLog(slowThresholdMs = 5000, level = "WARN")
    public List<Survey> getSurveysByUserId(Long userId) {
        // 5초 이상 걸리면 WARN 레벨로 로깅
        return surveyRepository.findByUserId(userId);
    }
}
```

---

### 3.5 외부 시스템 연동 로깅

#### 3.5.1 Gemini API 로깅

**구현 위치**: `com.example.thinkfast.service.ai.GeminiApiService`

**주요 기능**:
1. API 호출 시작/완료 시간 측정
2. 재시도 횟수 추적
3. 응답 상태 코드, 에러 메시지 로깅
4. 구조화된 필드:
   - `external_api.system`: "gemini"
   - `external_api.operation`: "generateContent"
   - `external_api.request_url`: API URL
   - `external_api.duration_ms`: 실행 시간
   - `external_api.status`: "success" | "failure"
   - `external_api.response_status`: HTTP 상태 코드
   - `external_api.retry_count`: 재시도 횟수
   - `external_api.error_message`: 에러 메시지

**코드 구조**:
```java
@Service
public class GeminiApiService {
    public String generateText(String prompt) {
        Instant startTime = Instant.now();
        AtomicInteger retryCount = new AtomicInteger(0);
        
        try {
            // MDC 설정
            MDC.put("log_type", "external_api");
            MDC.put("external_api.system", "gemini");
            MDC.put("external_api.operation", "generateContent");
            MDC.put("external_api.request_url", apiUrl);
            
            GeminiResponse response = webClient.post()
                    .uri(apiUrl)
                    .retryWhen(Retry.backoff(2, Duration.ofSeconds(1))
                            .doBeforeRetry(retrySignal -> {
                                retryCount.set(retrySignal.totalRetries() + 1);
                                MDC.put("external_api.retry_count", String.valueOf(retryCount.get()));
                            }))
                    .block();
            
            long duration = Duration.between(startTime, Instant.now()).toMillis();
            MDC.put("external_api.duration_ms", String.valueOf(duration));
            MDC.put("external_api.status", "success");
            MDC.put("external_api.response_status", "200");
            
            log.info("Gemini API 호출 성공: generateContent ({}ms, retries: {})", 
                    duration, retryCount.get());
            
            return response.getText();
        } catch (Exception e) {
            long duration = Duration.between(startTime, Instant.now()).toMillis();
            MDC.put("external_api.duration_ms", String.valueOf(duration));
            MDC.put("external_api.status", "failure");
            MDC.put("external_api.error_message", e.getMessage());
            
            log.error("Gemini API 호출 실패 ({}ms, retries: {})", 
                    duration, retryCount.get(), e);
            throw new AiServiceException("Gemini API 호출 실패", e);
        } finally {
            // MDC 정리
            MDC.remove("log_type");
            MDC.remove("external_api.system");
            // ...
        }
    }
}
```

#### 3.5.2 Redis 로깅

**구현 위치**: `com.example.thinkfast.realtime.RedisPublisher`

**주요 기능**:
1. Redis Pub/Sub 메시지 전송 시간 측정
2. 메시지 크기, 수신자 ID 로깅
3. 구조화된 필드:
   - `external_api.system`: "redis"
   - `external_api.operation`: "pubsub_send"
   - `external_api.channel`: Redis 채널명
   - `external_api.duration_ms`: 실행 시간
   - `external_api.status`: "success" | "failure"
   - `external_api.message_size`: 메시지 크기 (바이트)
   - `external_api.recipient_id`: 수신자 ID

**코드 구조**:
```java
@Service
public class RedisPublisher {
    public void sendAlarm(Long surveyId, String type) {
        long startTime = System.currentTimeMillis();
        
        try {
            MDC.put("log_type", "external_api");
            MDC.put("external_api.system", "redis");
            MDC.put("external_api.operation", "pubsub_send");
            MDC.put("external_api.channel", CHANNEL);
            
            // 메시지 생성 및 전송
            String json = objectMapper.writeValueAsString(alarmMessage);
            int messageSize = json.length();
            redisTemplate.convertAndSend(CHANNEL, json);
            
            long duration = System.currentTimeMillis() - startTime;
            MDC.put("external_api.duration_ms", String.valueOf(duration));
            MDC.put("external_api.status", "success");
            MDC.put("external_api.message_size", String.valueOf(messageSize));
            MDC.put("external_api.recipient_id", String.valueOf(userId));
            
            log.info("Redis Pub/Sub message sent: channel={}, recipient={}, size={} bytes ({}ms)", 
                    CHANNEL, userId, messageSize, duration);
        } catch (Exception e) {
            // 에러 처리
        } finally {
            // MDC 정리
        }
    }
}
```

---

### 3.6 스케줄러 작업 로깅

#### 3.6.1 기능 개요

스케줄러 작업 실행 시 Job ID, 실행 시간, 처리 건수 등을 구조화된 로그로 기록합니다.

#### 3.6.2 구현 위치

**클래스**: `com.example.thinkfast.scheduler.SurveySchedule`

#### 3.6.3 주요 기능

1. **Job ID 생성**
   - 형식: `job-{yyyyMMdd-HHmmss}-{type}`
   - 예: `job-20240115-120000-expired`

2. **실행 메트릭 수집**
   - 실행 시간 (`execution_time_ms`)
   - 처리 건수 (`processed_count`)
   - 실패 건수 (`failed_count`)
   - 작업 상태 (`status`: "success" | "failure" | "partial")

3. **구조화된 필드**
   - `log_type`: "scheduler"
   - `scheduler.job_name`: 작업 이름
   - `scheduler.job_id`: Job ID
   - `scheduler.execution_time_ms`: 실행 시간
   - `scheduler.processed_count`: 처리 건수
   - `scheduler.failed_count`: 실패 건수
   - `scheduler.status`: 작업 상태
   - `scheduler.error_message`: 에러 메시지 (실패 시)

#### 3.6.4 코드 구조

```java
@Scheduled(fixedRate = 60000)
@Transactional
public void updateExpiredSurvey() {
    String jobId = "job-" + LocalDateTime.now()
            .format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")) + "-expired";
    long startTime = System.currentTimeMillis();
    int processedCount = 0;
    AtomicInteger failedCount = new AtomicInteger(0);
    
    try {
        MDC.put("log_type", "scheduler");
        MDC.put("scheduler.job_name", "updateExpiredSurvey");
        MDC.put("scheduler.job_id", jobId);
        
        log.info("Scheduler job started: updateExpiredSurvey (jobId: {})", jobId);
        
        // 작업 수행
        List<Survey> expiredSurveys = surveyRepository.findByIsActiveTrueAndEndTimeBefore(now);
        expiredSurveys.forEach(survey -> {
            try {
                survey.setIsActive(false);
                processedCount++;
            } catch (Exception e) {
                failedCount.incrementAndGet();
                log.warn("Failed to process survey: ID={}", survey.getId(), e);
            }
        });
        
        long duration = System.currentTimeMillis() - startTime;
        int failed = failedCount.get();
        MDC.put("scheduler.execution_time_ms", String.valueOf(duration));
        MDC.put("scheduler.processed_count", String.valueOf(processedCount));
        MDC.put("scheduler.failed_count", String.valueOf(failed));
        MDC.put("scheduler.status", failed > 0 ? "partial" : "success");
        
        log.info("Scheduler job completed: updateExpiredSurvey (jobId: {}, duration: {}ms, processed: {}, failed: {})", 
                jobId, duration, processedCount, failed);
    } catch (Exception e) {
        long duration = System.currentTimeMillis() - startTime;
        MDC.put("scheduler.execution_time_ms", String.valueOf(duration));
        MDC.put("scheduler.status", "failure");
        MDC.put("scheduler.error_message", e.getMessage());
        
        log.error("Scheduler job failed: updateExpiredSurvey (jobId: {}, duration: {}ms)", 
                jobId, duration, e);
    } finally {
        // MDC 정리
        MDC.remove("log_type");
        MDC.remove("scheduler.job_name");
        // ...
    }
}
```

---

### 3.7 민감 정보 마스킹

#### 3.7.1 기능 개요

로그에 기록되는 민감 정보(비밀번호, API 키, 개인정보 등)를 자동으로 마스킹합니다.

#### 3.7.2 구현 위치

**클래스**: `com.example.thinkfast.common.utils.LogMaskingUtil`

#### 3.7.3 마스킹 대상

1. **API 키, 토큰, 비밀번호**
   - `api_key=***`, `token=***`, `password=***` 등

2. **이메일 주소**
   - 사용자명 부분만 마스킹 (예: `ab***c@example.com`)

3. **전화번호**
   - 형식: `010-****-1234`

4. **주민등록번호**
   - 형식: `123456-*******`

5. **신용카드 번호**
   - 형식: `1234-****-****-5678`

#### 3.7.4 사용 방법

```java
// 쿼리 문자열 마스킹
String queryString = request.getQueryString();
if (queryString != null) {
    String masked = LogMaskingUtil.maskSensitiveInfo(queryString);
    MDC.put("http.query_string", masked);
}

// JSON 문자열 마스킹
String json = objectMapper.writeValueAsString(data);
String masked = LogMaskingUtil.maskSensitiveJson(json);

// URL 마스킹
String url = "https://api.example.com?api_key=secret123";
String masked = LogMaskingUtil.maskSensitiveUrl(url);
```

---

## 4. 설정 및 구성

### 4.1 build.gradle 의존성

```gradle
dependencies {
    // Logstash Logback Encoder (JSON 로깅)
    implementation 'net.logstash.logback:logstash-logback-encoder:7.4'
    
    // 기타 의존성...
}
```

### 4.2 logback-spring.xml 설정

**파일 위치**: `src/main/resources/logback-spring.xml`

**주요 설정**:

1. **환경별 프로파일 분리**
   - `local`: 텍스트 포맷 (콘솔 출력)
   - `prod`: JSON 포맷 (콘솔 + 파일 출력)

2. **JSON Encoder 설정**
   - `LogstashEncoder` 사용
   - 공통 필드: `service`, `env`
   - MDC 필드 포함: `request_id`, `trace_id`, `user_id`

3. **파일 Appender 설정**
   - 파일 경로: `${LOG_FILE}` (application.yml에서 설정)
   - 롤링 정책: 날짜 + 크기 기반
   - 최대 파일 크기: 100MB
   - 보관 기간: 90일
   - 최대 전체 크기: 3GB

4. **패키지별 로그 레벨**
   - `com.example.thinkfast`: INFO
   - 외부 라이브러리: WARN
   - Hibernate SQL (prod): INFO
   - Hibernate SQL (local): DEBUG

### 4.3 application-prod.yml 설정

```yaml
logging:
  file:
    name: /var/log/thinkfast/application.log
    max-size: 100MB
    max-history: 30
  level:
    org.hibernate.SQL: INFO
    org.hibernate.type.descriptor.sql.BasicBinder: OFF
```

### 4.4 필터/인터셉터 등록

**RequestIdFilter**: `@Component`, `@Order(1)`로 자동 등록

**ExceptionLoggingFilter**: `@Component`로 자동 등록

**LoggingInterceptor**: `WebConfig`에서 인터셉터로 등록 필요

---

## 5. 사용 방법

### 5.1 일반 로깅

기존과 동일하게 SLF4J 로거 사용:

```java
@Slf4j
@Service
public class SurveyService {
    public Survey getSurvey(Long id) {
        log.info("Survey 조회: id={}", id);
        return surveyRepository.findById(id).orElseThrow();
    }
}
```

**Production 환경에서 JSON 포맷으로 자동 출력**:
```json
{
  "@timestamp": "2024-01-15T12:00:00.000Z",
  "level": "INFO",
  "service": "thinkfast",
  "env": "prod",
  "request_id": "req-abc123",
  "trace_id": "trace-xyz789",
  "message": "Survey 조회: id=123"
}
```

### 5.2 성능 측정 로깅

메서드에 `@PerformanceLog` 어노테이션 추가:

```java
@Service
public class SurveyService {
    @PerformanceLog(slowThresholdMs = 2000, level = "INFO")
    public List<Survey> getSurveysByUserId(Long userId) {
        return surveyRepository.findByUserId(userId);
    }
}
```

### 5.3 MDC를 사용한 구조화 로깅

필요한 경우 MDC에 직접 필드 추가:

```java
@Service
public class SurveyService {
    public Survey createSurvey(SurveyDto dto) {
        MDC.put("log_type", "business");
        MDC.put("survey.title", dto.getTitle());
        MDC.put("survey.type", dto.getType());
        
        try {
            Survey survey = surveyRepository.save(new Survey(dto));
            log.info("Survey 생성 완료: id={}", survey.getId());
            return survey;
        } finally {
            MDC.remove("log_type");
            MDC.remove("survey.title");
            MDC.remove("survey.type");
        }
    }
}
```

---

## 6. 로그 스키마

### 6.1 공통 필드

모든 로그에 포함되는 필드:

| 필드명 | 타입 | 설명 | 예시 |
|--------|------|------|------|
| @timestamp | date | 로그 발생 시간 (ISO 8601) | 2024-01-15T12:00:00.000Z |
| level | keyword | 로그 레벨 | INFO, ERROR, WARN, DEBUG |
| service | keyword | 서비스명 | thinkfast |
| env | keyword | 환경 정보 | prod, local |
| host | keyword | 서버 호스트명 | server-hostname |
| log_type | keyword | 로그 타입 | http_request, exception, external_api, scheduler, async, performance |
| message | text | 사람이 읽을 수 있는 요약 메시지 | HTTP request received: POST /api/surveys |
| request_id | keyword | 단일 요청 추적 ID | req-abc123 |
| trace_id | keyword | 분산 추적 ID | trace-xyz789 |
| user_id | keyword | 사용자 ID (인증된 경우) | user@example.com |

### 6.2 로그 타입별 필드

상세한 로그 스키마는 `docs/logging-schema.md` 파일을 참고하세요.

---

## 7. 참고 자료

- **로그 스키마 문서**: `docs/logging-schema.md`
- **Filebeat 설정 예시**: `docs/filebeat-config.yml`
- **Logstash 파이프라인 예시**: `docs/logstash-pipeline.conf`
- **구현 검토 리포트**: `로깅시스템_구현검토_리포트.md`

---

**작성자**: 개발팀  
**최종 수정일**: 2025-01-15
